
use v6.d;
use lib 'lib';
use BDD::Behave::Actions;
use BDD::Behave::Files;
use BDD::Behave::Grammar;
use BDD::Behave::Lets;
use Test;
use Test::Output;

plan 3;

my $m;
my $k;
my $out;
my $str;

$k = q:to/END/;

use BDD::Behave;

class Foo {
  has $!bar;
  has $!baz;

  submethod BUILD(:$!bar) {
    $!baz = 42;
  }
}

let(:foo) => { Foo.new(17) };

describe -> 'Foo' {
  it -> '.bar' {
    expect(:foo).to.be(17);
  }
}

END

Files.current = 'test';
$out = "\n    \x[1B][36m⮑  \x[1B][0m'Foo' \n        \x[1B][36m⮑  \x[1B][0m'.bar' \n            \x[1B][36m⮑  \x[1B][0m\x[1B][31mFAILURE\x[1B][0m\n";
$m = Grammar.parse($k, :rule<TOP>);
output-is { $m = Grammar.parse($k, :rule<TOP>) }, $out, '<TOP> parses correctly';
ok $m.defined, 'parser returns a match';
ok $m.Str eq $k, 'match spans full source';
