
use v6.d;
use lib 'lib';
use BDD::Behave::Actions;
use BDD::Behave::Files;
use BDD::Behave::Grammar;
use BDD::Behave::Lets;
use Test;
use Test::Output;

plan 8;

my $m;
my $k;
my $out;
my $str;

$out = "    \x[1B][36mâ®‘  \x[1B][0m\x[1B][32mSUCCESS\x[1B][0m\n";
output-is { $m = Grammar.parse('expect(1).to.be(1);', :rule<expectation>) }, $out, '<expectation> parses correctly';
ok $m.Str eq 'expect(1).to.be(1);';
output-is { $m = Grammar.parse('expect( 1).to.be( 1);', :rule<expectation>) }, $out, '<expectation> parses correctly';
ok $m.Str eq 'expect( 1).to.be( 1);';
output-is { $m = Grammar.parse('expect(1 ).to.be(1 );', :rule<expectation>) }, $out, '<expectation> parses correctly';
ok $m.Str eq 'expect(1 ).to.be(1 );';
output-is { $m = Grammar.parse('expect( 1 ).to.be( 1 );', :rule<expectation>) }, $out, '<expectation> parses correctly';
ok $m.Str eq 'expect( 1 ).to.be( 1 );';
